#![no_std]
#![no_main]

// pick a panicking behavior
use panic_halt as _; // you can put a breakpoint on `rust_begin_unwind` to catch panics

// extern crate to get the project compiling while these crates are not used yet
extern crate cortex_m;
extern crate cortex_m_rt;
// extern crate stm32f1xx_hal::stm32f1::stm32f103 as hal;

// use stm32f1::stm32f103; // The peripherals access crate autogenerated from svd file
use cortex_m_rt::{entry, exception, ExceptionFrame};
use rtt_target::{debug_rtt_init_print, debug_rprintln};
use stm32f1xx_hal::{
    pac,
    prelude::*,
    serial::{Config, Serial},
};
use nb::block;
// use core::ptr;


#[entry]
fn main() -> ! {
    debug_rtt_init_print!(); // nop in --release
    
    let p = pac::Peripherals::take().unwrap();
    let mut flash = p.FLASH.constrain();
    let rcc = p.RCC.constrain();
    let clocks = rcc.cfgr.freeze(&mut flash.acr);

    // Prepare the alternate function I/O registers
    let mut afio = p.AFIO.constrain();

    // Prepare the GPIOB peripheral
    let mut gpioa = p.GPIOA.split();


    let tx = gpioa.pa2.into_alternate_push_pull(&mut gpioa.crl);
    let rx = gpioa.pa3;

    let default_config = Config::default();

    let mut serial = Serial::new(
        p.USART2,
        (tx, rx),
        &mut afio.mapr,
        default_config.wordlength_8bits().baudrate(115200.bps()),
        &clocks,
    );

    let sent = b'X';
    block!(serial.write(sent)).ok();
    let sent = b'Y';
    block!(serial.write(sent)).ok();
    let sent = b'Z';
    block!(serial.write(sent)).ok();

    loop {     
        // your code goes here 
    }
}

#[exception]
unsafe fn HardFault(ef: &ExceptionFrame) -> ! {
    debug_rprintln!("{:#?}", ef);

    loop {}
}
