#![no_std]
#![no_main]

mod ring_buffer;

use core::{cell::RefCell, fmt::Write, ops::DerefMut, ptr};

use cortex_m::interrupt::Mutex;
// pick a panicking behavior
use panic_halt as _; // you can put a breakpoint on `rust_begin_unwind` to catch panics

use ring_buffer::RingBuffer;
use stm32f1::stm32f103::USART2; // The peripherals access crate autogenerated from svd file
use cortex_m_rt::{entry, exception, ExceptionFrame};
use rtt_target::{debug_rtt_init_print, debug_rprintln};
use stm32f1xx_hal::{
    pac,
    prelude::*,
    serial::{Config, Serial},
};
use stm32f1xx_hal::pac::interrupt;

static RX: Mutex<RefCell<Option<stm32f1xx_hal::serial::Rx<USART2>>>> = Mutex::new(RefCell::new(None));
static BUFFER: Mutex<RefCell<Option<RingBuffer>>> = Mutex::new(RefCell::new(None));

#[entry]
fn main() -> ! {
    debug_rtt_init_print!(); // nop in --release
    
    let p = pac::Peripherals::take().unwrap();
    let mut flash = p.FLASH.constrain();
    let rcc = p.RCC.constrain();
    let clocks = rcc.cfgr.freeze(&mut flash.acr);

    // Prepare the alternate function I/O registers
    let mut afio = p.AFIO.constrain();
    let mut gpioa = p.GPIOA.split();


    let tx_pin = gpioa.pa2.into_alternate_push_pull(&mut gpioa.crl);
    let rx_pin = gpioa.pa3;

    let default_config = Config::default();

    unsafe { pac::NVIC::unmask(pac::Interrupt::USART2); }
    

    let serial = Serial::new(
        p.USART2,
        (tx_pin, rx_pin),
        &mut afio.mapr,
        default_config.wordlength_8bits().baudrate(115200.bps()),
        &clocks,
    );

    let (mut _tx, mut rx) = serial.split();

    // let sent = b'X';
    // block!(serial.write(sent)).ok();
    // let sent = b'Y';
    // block!(serial.write(sent)).ok();
    // let sent = b'Z';
    // block!(serial.write(sent)).ok();

    // serial.listen(Event::Rxne);
    // serial.listen(Event::Idle);
    // serial.listen(Event::Txe);
    _tx.write_char('x').ok();

    rx.listen();
    // rx.listen_idle();

    let buffer = RingBuffer::new();
    
    cortex_m::interrupt::free(|cs| RX.borrow(cs).replace(Some(rx)));
    cortex_m::interrupt::free(|cs| BUFFER.borrow(cs).replace(Some(buffer)));
    // provoke hard fault
    // unsafe {
    //     ptr::read_volatile(0x3FFF_0000 as *const u32);
    // }

    loop {     
        let mut complete = false;
        cortex_m::interrupt::free(|cs| {
            if let Some(ref mut buffer) = BUFFER.borrow(cs).borrow_mut().deref_mut(){
                complete = buffer.complete;
                if complete {
                    buffer.reset();
                }
            }
        });  

        if complete {
            _tx.write_str("Complete!").ok();
        }
    }
}

#[exception]
unsafe fn HardFault(ef: &ExceptionFrame) -> ! {
    debug_rprintln!("{:#?}", ef);

    loop {}
}

#[interrupt]
fn USART2() {    
    cortex_m::interrupt::free(|cs| {
        if let Some(ref mut rx) = RX.borrow(cs).borrow_mut().deref_mut() {
            if rx.is_rx_not_empty() {

                if let Some(ref mut buffer) = BUFFER.borrow(cs).borrow_mut().deref_mut(){
                    if let Some(value) = rx.read().ok() {
                        if value == 32 {
                            buffer.complete = true;
                        }
                        else {
                            buffer.add(value);
                        }
                    }
                }
            }
        }
    })
}